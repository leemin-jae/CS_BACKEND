# CS_BACKEND
cs 면접 정리

## CS 관련 지식

### DB

<details>
  <summary>데이터베이스, DBMS란 무엇인가, 사용하는 이유는 무엇인가</summary>
  </br>
  <p>DB (데이터베이스)는 체계적으로 구성된 데이터의 모임을 말합니다. 데이터는 컴퓨터에서 처리할 수 있는 숫자, 문자, 이미지, 음성 등의 형태가 있으며, 데이터베이스는 이러한 데이터들이 저장, 관리, 처리되는 공간입니다.</p>
  <p>DBMS는 데이터베이스 관리 시스템으로, 여러 사용자가 DB에 접근, 사용할 수 있도록 해주는 소프트웨어</p>
  <p>파일 시스템의 단점을 보완하여 데이터의 중복, 검색 등의 문제를 해결하기 위해서 사용</p>
</details>

<details>
  <summary>RDBMS vs NOSQL에 대해서 설명해주세요.</summary>
  </br>
  <p>RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.</p>
  <p>장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.</p>
  <p>NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다. 다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, bigtable, dynamo, document db, graph db 등이 있습니다.</p>
  <p>둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.</p>
</details>


<details>
  <summary>데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.</summary>
  </br>
  <p>데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.</p>
  <p>하지만 검색성능을 실질적으로 향상시키기 위해서는 해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 합니다.</p>
  <p>인덱스는 보통 B-트리(B-Tree)나 해시(Hash) 등의 자료구조를 사용하여 구현됩니다. B-트리 인덱스는 범위 검색에 뛰어나고, 해시 인덱스는 등값 검색에 효과적입니다.</p>
  <p>일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.</p>
  <p>일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다.인덱스를 생성하면 디스크 공간과 추가적인 쓰기 연산이 필요하므로, 인덱스를 너무 많이 사용하면 오히려 성능이 저하될 수 있습니다. 또한 인덱스가 자주 업데이트되는 경우에는 오버헤드가 발생할 수 있습니다. </p>
  <p>따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.</p>
</details>

<details>
  <summary>인덱스 클러스터링(Index Clustering)이란 무엇이며 어떤 장단점이 있나요?</summary>
  </br>
  <p>인덱스 클러스터링(Index Clustering)은 데이터베이스에서 인덱스와 데이터가 물리적으로 동일한 영역에 저장되는 것을 의미합니다. 즉, 클러스터형 인덱스(Clustered Index)를 생성하면 인덱스 키의 값을 기준으로 데이터가 정렬되어 저장됩니다.</p>
  <p> 장점
    <ul>
      <li>테이블에 대한 클러스터형 인덱스는 하나만 생성할 수 있습니다. 따라서 테이블에 대해 자주 사용되는 여러 개의 쿼리가 있다면, 하나의 클러스터형 인덱스로 모두 처리할 수 없을 수 있습니다.</li>
      <li>클러스터형 인덱스의 키 값이 변경되는 경우, 해당 레코드를 다시 정렬해야 하기 때문에 비용이 많이 듭니다. 따라서 키 값이 자주 변경되는 테이블에서는 클러스터형 인덱스를 사용하는 것이 적합하지 않을 수 있습니다.</li>
      <li>클러스터형 인덱스를 사용하면 인덱스 키의 값에 따라 데이터가 정렬되어 저장되기 때문에, 키 값의 분포가 균등하지 않은 경우 인덱스의 효율성이 떨어질 수 있습니다.</li>
    </ul>
  </p>
  <p> 단점
    <ul>
      <li>데이터베이스에서 인덱스를 검색할 때 물리적인 I/O 비용이 감소합니다. 클러스터형 인덱스는 인덱스 키의 값을 기준으로 데이터가 정렬되어 저장되기 때문에 검색 시 빠르게 찾을 수 있습니다.</li>
      <li>범위 검색(Range Scan)의 성능이 향상됩니다. 클러스터형 인덱스는 인덱스 키의 값에 따라 데이터가 정렬되어 저장되기 때문에 범위 검색 시 효율적으로 처리할 수 있습니다.</li>
    </ul>
  </p>
  <p>어떤 인덱스를 사용할지 선택하는 것은 해당 테이블에 대한 데이터의 사용 패턴에 따라 달라질 수 있습니다. 검색 작업이 빈번하고 대량의 데이터가 저장된 경우 클러스터형 인덱스를 사용하는 것이 적합하며, 검색 작업보다는 데이터 수정, 삭제, 추가 등의 작업이 빈번하게 발생하는 경우에는 비클러스터형 인덱스를 사용하는 것이 적합합니다.</p>
</details>

<details>
  <summary>클러스터형 인덱스(Clustered Index)와 비클러스터형 인덱스(Non-clustered Index)의 차이는 무엇인가요?</summary>
  </br>
  <p>데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.</p>
  <p>
    <ul>
      <li>클러스터형 인덱스: 테이블의 모든 데이터를 지정된 칼럼 기준으로 정렬하여 저장하는 인덱스입니다. 이 때 지정된 칼럼은 유일한 값을 가져야 합니다. 클러스터형 인덱스는 테이블 당 하나만 생성할 수 있으며, 테이블 자체가 인덱스를 형성하므로 데이터베이스에서 매우 빠른 검색 속도를 제공합니다.</li>
      <li>비클러스터형 인덱스: 인덱스가 지정된 칼럼을 기준으로 데이터를 정렬하지만, 데이터 자체는 인덱스와 별도의 영역에 저장됩니다. 이 때 지정된 칼럼은 유일한 값을 가질 필요가 없습니다. 하나의 테이블에 여러 개의 비클러스터형 인덱스를 생성할 수 있으며, 인덱스를 사용하여 데이터를 찾는 데 시간이 더 걸릴 수 있지만, 데이터의 추가, 수정, 삭제 등의 작업이 발생했을 때 클러스터형 인덱스보다 더 빠르게 처리됩니다.</li>
    </ul>
  </p>
  <p>어떤 인덱스를 사용할지 선택하는 것은 해당 테이블에 대한 데이터의 사용 패턴에 따라 달라질 수 있습니다. 검색 작업이 빈번하고 대량의 데이터가 저장된 경우 클러스터형 인덱스를 사용하는 것이 적합하며, 검색 작업보다는 데이터 수정, 삭제, 추가 등의 작업이 빈번하게 발생하는 경우에는 비클러스터형 인덱스를 사용하는 것이 적합합니다.</p>
</details>

<details>
  <summary>트랜잭션에 대해서 설명해주세요.</summary>
  </br>
  <p>트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위라고 할 수 있으며, 트랜잭션에는 여러개의 연산이 수행될 수 있습니다.</p>
  <p>트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다.</p>
  <p> 트랜잭션은 데이터베이스에서 데이터의 일관성과 무결성을 보장하는 데 필수적인 개념이며, 데이터베이스에서 데이터를 안전하게 처리하기 위해서 반드시 사용되어야 합니다.</p>
</details>

<details>
  <summary>ACID에 대해서 설명해주세요.</summary>
  </br>
  <p>ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.</p>
  <p>
    <ul>
      <li>Atomicity(원자성): 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패해야 합니다.</li>
      <li>Consistency(일관성): 트랜잭션은 유효한 상태로만 변경될 수 있습니다. DB 규칙, 조건 등을 지켜야한다.</li>
      <li>Isolation(고립성): 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.</li>
      <li>Durability(내구성): 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)</li>
    </ul>
  </p>
</details>

<details>
  <summary>트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.</summary>
  </br>
  <p>트랜잭션 격리 수준(Transaction Isolation Level)은 여러 개의 트랜잭션이 동시에 실행될 때, 각 트랜잭션이 다른 트랜잭션의 영향을 받는 정도를 나타내는 개념입니다. 데이터베이스 시스템은 트랜잭션 격리 수준을 설정하여 데이터의 일관성과 무결성을 유지하면서 동시성을 향상시킵니다.</p>
  <p>
    <ul>
      <li>READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다.</li>
      <li>READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다.</li>
      <li>REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.</li>
      <li>SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다. 모든 트랜잭션을 순차적으로 실행하는 것처럼 동작합니다.(성능 매우 떨어짐)</li>
    </ul>
  </p>
</details>

<details>
  <summary>트랜잭션의 락(Lock)이란 무엇인가요? 공유 락(Shared Lock)과 배타적 락(Exclusive Lock)의 차이는 무엇인가요?</summary>
  </br>
  <p>트랜잭션에서 락(Lock)은 동시에 여러 트랜잭션이 같은 데이터에 접근할 때, 데이터의 일관성과 무결성을 유지하기 위해 사용되는 기술입니다. 트랜잭션이 데이터에 락을 걸면, 다른 트랜잭션은 그 데이터를 변경하거나 접근할 수 없게 됩니다.</p>
  <p>공유 락(Shared Lock)은 여러 트랜잭션이 동시에 데이터를 읽을 수 있는 락입니다. 여러 트랜잭션이 동시에 같은 데이터에 접근할 수 있지만, 그 데이터를 변경할 수 없습니다. 공유 락을 사용하는 경우 데이터베이스는 데이터의 일관성을 유지하면서 여러 트랜잭션이 동시에 데이터를 읽을 수 있도록 합니다.</p>
  <p>배타적 락(Exclusive Lock)은 특정 트랜잭션이 데이터를 읽고 쓸 수 있는 락입니다. 배타적 락을 건 트랜잭션이 해당 데이터를 사용 중일 때, 다른 트랜잭션은 그 데이터를 읽거나 쓸 수 없습니다. 배타적 락을 사용하는 경우 데이터베이스는 데이터의 무결성을 보장하기 위해 여러 트랜잭션들이 동시에 데이터를 변경하는 것을 방지합니다.</p>
</details>

<details>
  <summary>트랜잭션의 데드락(Deadlock)이란 무엇인가요? 이를 방지하기 위한 방법은 무엇인가요?</summary>
  </br>
  <p>데드락(Deadlock)은 두 개 이상의 트랜잭션이 서로 상대방이 가지고 있는 락을 기다리며 무한히 대기하는 상황을 말합니다. 이러한 상황에서는 어떤 트랜잭션도 진행되지 못하며, 시스템의 성능 저하나 데이터 불일치 문제를 일으킬 수 있습니다.</p>
  <p>데드락을 방지하기 위한 방법은 크게 두 가지가 있습니다. 첫 번째 방법은 트랜잭션들이 데이터베이스 객체에 접근하는 순서를 일관성 있게 유지하는 것입니다. 이를 위해서는 트랜잭션들이 데이터베이스 객체에 접근할 때 일정한 순서로 접근하도록 강제하는 방법이 있습니다. 두 번째 방법은 트랜잭션들이 필요한 데이터베이스 객체를 사용할 때 락을 설정하는 순서를 일관성 있게 유지하는 것입니다. 이를 위해서는 모든 트랜잭션에서 데이터베이스 객체에 접근할 때 일정한 순서로 락을 설정하도록 강제하는 방법이 있습니다.</p>
</details>


<details>
  <summary>정규화에 대해서 설명해주세요.</summary>
  </br>
  <p>정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미합니다.</p>
  <p>데이터베이스 설계 시에는 데이터 중복성을 최소화하고 일관성을 유지하는 것이 중요한데, 이를 위해서는 각 데이터 요소가 중복되지 않도록 테이블을 분리하고, 각각의 테이블 간에 관계를 설정해야 합니다. 이러한 과정에서 정규화를 수행합니다.</p>
   <p>
    <ul>
      <li>제1정규화(1NF) : 테이블의 각 필드는 원자값(Atomic value)만을 포함하도록 분해합니다.</li>
      <li>제2정규화(2NF) : 테이블의 모든 필드가 기본 키에 대해 완전 함수 종속( Fully functional dependency)을 갖도록 테이블을 분해합니다.</li>
      <li>제3정규화(3NF) : 테이블에서 이행적 함수 종속(Transitive dependency)이 존재하지 않도록 테이블을 분해합니다.</li>
    </ul>
  </p>
</details>

<details>
  <summary>JOIN에 대해서 설명해주세요.</summary>
  </br>
  <p>JOIN은 두 개 이상의 테이블에서 데이터를 검색하거나 결합하는 방법입니다. JOIN은 데이터베이스에서 가장 많이 사용되는 연산 중 하나이며, 테이블 간 관계를 사용해 데이터를 가져오는 데 사용됩니다.</p>
  <p>JOIN은 일반적으로 두 가지 방법으로 수행됩니다. 첫 번째 방법은 Nested Loop Join입니다. 이 방법은 두 테이블을 루프로 반복하고 조건을 충족하는 행을 찾아 조인합니다. 두 번째 방법은 Hash Join입니다. 이 방법은 두 테이블을 해시 함수를 사용해 조인합니다. 해시 함수는 데이터의 일부를 사용해 키를 만들고 이를 사용해 테이블을 연결합니다.</p>
</details>


<details>
  <summary>Redis에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>Redis는 메모리 기반의 Key-Value 형태의 오픈소스 데이터베이스이며, NoSQL 데이터베이스의 일종입니다. 데이터를 디스크가 아닌 메모리에 저장하기 때문에 속도가 빠르며, 데이터 처리 속도가 빠르다는 장점이 있습니다.</p>
    <p>특징
    <ul>
      <li>In-Memory 데이터베이스: 데이터를 메모리에 저장하기 때문에 처리 속도가 매우 빠르며, 캐시로 많이 사용됩니다.</li>
      <li>다양한 데이터 타입 지원: 문자열(String), 리스트(List), 셋(Set), 정렬된 셋(Sorted Set), 해시(Hash) 등 다양한 데이터 타입을 지원합니다.</li>
      <li>높은 가용성(High Availability): 마스터-슬레이브 복제 기능을 지원하여, 마스터 노드가 다운되었을 때 자동으로 슬레이브 노드가 마스터 역할을 대신 수행할 수 있습니다.
      </li>
      <li>데이터 영속화(Persistence): RDB와 AOF 방식을 지원하여, 데이터의 영속성을 보장합니다.</li>
    </ul>
  </p>
  <p>스프링에서는 세션을 관리하거나, 캐싱을 하는데에 자주 사용되는 것으로 알고 있습니다.</p>
</details>

<details>
  <summary>Redis와 Memcached의 차이에 대해서 설명해주세요.</summary>
  </br>
  <p>Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원해서 멀티 프로세싱이 가능합니다.</p>
  <p>Redis는 다양한 자료구조를 지원하고, Memcached는 문자열 형태로만 저장합니다.</p>
  <p>Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원합니다.</p>
  <p>Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.</p>
</details>

<details>
  <summary>Elastic Search에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다. 보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 Logstash, Kibana, Beats를 추가적으로 사용합니다.</p>
  <p>Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.</p>
  <p>다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)</p>
</details>

<details>
  <summary>Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다. 이는 책의 색인을 생각해보면 쉬운데, 특정 단어가 출현하는 doc을 저장하는 것입니다. 반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지 어떤 순서로 저장하는 지의 차이라고 생각합니다. RDBMS에도 다양한 인덱스 구조가 있으나 여기서 예로 든 것은 B-Tree 인덱스입니다.</p>
</details>

<details>
  <summary>Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search의 키워드 검색은 document를 저장할 때 수행하는 알고리즘과 동일한 알고리즘으로 키워드를 분리합니다. 그 중에서 랭킹알고리즘을 통해서 가장 유사한 순서대로 결과를 나타냅니다.</p>
  <p>RDBMS에서의 LIKE 검색은 와일드카드로 시작하지 않는 경우에만 인덱스를 사용하고 나머지 경우는 전체를 탐색하기 때문에 상대적으로 느립니다.</p>
</details>

<details>
  <summary>MongoDB에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>CAP 이론과, Eventual Consistency에 대해서 설명해주세요.</summary>
  </br>
  <p>CAP 이론은 분산 환경에서 모두를 만족하는 시스템은 없다는 이론입니다.</p>
  <p>
    <ul>
      <li>Consitenty(일관성): ACID의 일관성과는 약간 다릅니다. 모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다.</li>
      <li>Availability(가용성): 모든 동작에 대한 응답이 리턴되어야 합니다.</li>
      <li>Partition Tolerance(분할 내성): 시스템 일부가 네트워크에서 연결이 끊기더라도 동작해야 합니다.</li>
    </ul>
  </p>
  <p>CAP는 해당 시스템이 이거다 하고 말하기 곤란한게 어떻게 클러스터링 하느냐에 따라 달라질 수 있습니다. 그렇기 때문에 어떤 전략을 취할 때 어떤 것을 선택했는가를 잘 알아야 합니다. (단순히 MySQL이 CA입니다. 보다는 어떤 이유로 CA인지 근거를 생각해보기) 그리고 어느정도 한계가 있는 이론이고 PACELC 이론이라고 또 있습니다.</p>
  <p>Eventual Consistency는 이 Consistency를 보장해주지 못하기 때문에 나온 개념으로, Consistency를 완전히 보장하지는 않지만, 결과적으로 언젠가는 Conssistency가 보장됨을 의미합니다.</p>
</details>


<details>
  <summary>추가 정리</summary>
쿼리 튜닝(Query tuning)이란 무엇이며 어떤 방법이 있는가요?
데이터베이스 백업과 복구에 대해 설명해주세요.
데이터베이스 보안에 대해 설명해주세요.
SQL Injection이란 무엇이며 어떻게 방지할 수 있나요?
데이터베이스 트리거(Trigger)란 무엇이며 어떤 경우에 사용하나요?
데이터베이스 뷰(View)란 무엇이며 어떤 경우에 사용하나요?
데이터베이스 샤딩(Sharding)이란 무엇이며 어떤 장단점이 있나요?
데이터베이스 파티셔닝(Partitioning)이란 무엇이며 어떤 경우에 사용하나요?
데이터베이스 쿼리(Query) 최적화에 대해 설명해주세요.
OLTP(Online Transaction Processing)와 OLAP(Online Analytical Processing)의 차이점은 무엇인가요?
데이터베이스 스키마(Schema)란 무엇이며 어떤 경우에 사용하나요?
데이터베이스 복제(Replication)란 무엇이며 어떤 경우에 사용하나요?
Table과 View의 차이
DB Key 종류 및 의미
</details>
